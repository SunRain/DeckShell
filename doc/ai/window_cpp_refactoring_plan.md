# Window.cpp 重构计划

## 项目概述

重构 `examples/test_skip_multitaskview_window/window.cpp` 中的代码，遵循现代C++（C++17或更高版本）和Qt（Qt 6.x）最佳实践，重点改进代码可读性、性能、内存管理、错误处理和资源使用。

## 当前代码分析

### 文件结构
- **window.cpp** (320行) - 核心窗口管理类
- **window.h** - 头文件定义
- **waylandmanager.cpp** - Wayland协议管理器
- **shellsurface.cpp** - Shell surface封装
- **mainwindow.cpp** - 测试界面
- **main.cpp** - 程序入口点

### 主要问题识别

1. **内存管理问题**
   - 使用裸指针：`ShellSurface *m_shellSurface`、`WaylandManager *s_waylandManager`
   - 手动内存管理容易导致内存泄漏
   - 缺乏RAII原则应用

2. **资源管理**
   - 静态变量管理不够安全
   - 对象生命周期管理复杂
   - 异常安全性不足

3. **代码结构**
   - 函数过长，职责不清晰
   - 静态方法过多，耦合度高
   - 初始化逻辑分散

4. **Qt最佳实践**
   - 可以优化信号槽连接
   - 缺少QPointer等Qt智能指针使用
   - 事件过滤器处理可改进

## 重构计划 TODO

### 阶段1: 代码分析与准备
- [ ] **1.1** 详细分析当前代码的所有问题和依赖关系
- [ ] **1.2** 确定重构范围和兼容性要求
- [ ] **1.3** 制定代码备份和版本控制策略
- [ ] **1.4** 设立编译和测试基准

### 阶段2: 内存管理重构
- [ ] **2.1** 将裸指针替换为智能指针
  - `std::unique_ptr` 用于独占所有权
  - `std::shared_ptr` 用于共享资源
  - `QPointer` 用于Qt对象监控
- [ ] **2.2** 重构静态成员变量管理
  - 使用RAII包装器或单例模式
  - 确保线程安全
- [ ] **2.3** 消除手动delete调用
- [ ] **2.4** 实现异常安全的资源管理

### 阶段3: RAII原则应用
- [ ] **3.1** 重构资源获取和释放逻辑
- [ ] **3.2** 使用作用域保护（scope guards）
- [ ] **3.3** 实现自动资源清理
- [ ] **3.4** 确保异常安全性

### 阶段4: 错误处理优化
- [ ] **4.1** 添加comprehensive错误检查
- [ ] **4.2** 使用 `std::optional` 处理可能失败的操作
- [ ] **4.3** 实现异常安全的错误传播
- [ ] **4.4** 添加详细的错误日志记录
- [ ] **4.5** 处理边缘情况和异常条件

### 阶段5: 现代C++特性应用
- [ ] **5.1** 使用 `auto` 关键字简化类型声明
- [ ] **5.2** 应用 `std::optional` 处理可选值
- [ ] **5.3** 使用结构化绑定简化返回值处理
- [ ] **5.4** 应用 `if constexpr` 优化条件编译
- [ ] **5.5** 使用 lambda 表达式简化回调
- [ ] **5.6** 应用移动语义优化性能

### 阶段6: Qt最佳实践
- [ ] **6.1** 更新信号槽连接为新式语法
- [ ] **6.2** 优化QObject生命周期管理
- [ ] **6.3** 改进事件过滤器实现
- [ ] **6.4** 使用Qt容器和算法优化
- [ ] **6.5** 实现proper Qt parent-child关系

### 阶段7: 函数和类设计优化
- [ ] **7.1** 分解复杂函数为更小、更专注的函数
- [ ] **7.2** 重构静态方法，减少全局状态
- [ ] **7.3** 实现单一职责原则
- [ ] **7.4** 改进接口设计和封装
- [ ] **7.5** 添加const正确性

### 阶段8: 性能优化
- [ ] **8.1** 避免不必要的对象拷贝
- [ ] **8.2** 优化字符串处理
- [ ] **8.3** 使用move语义减少分配
- [ ] **8.4** 优化循环和算法复杂度
- [ ] **8.5** 减少内存分配/释放次数

### 阶段9: 类型安全和正确性
- [ ] **9.1** 添加const正确性
- [ ] **9.2** 使用强类型包装器
- [ ] **9.3** 消除未定义行为
- [ ] **9.4** 添加静态断言验证
- [ ] **9.5** 实现边界检查

### 阶段10: 验证和测试
- [ ] **10.1** 编译测试确保无错误和警告
- [ ] **10.2** 功能测试验证行为一致性
- [ ] **10.3** 性能基准测试
- [ ] **10.4** 内存泄漏检测
- [ ] **10.5** 代码审查和最终优化

## 技术方案详情

### 内存管理改进

```cpp
// 当前代码 (需要改进)
ShellSurface *m_shellSurface = nullptr;
static WaylandManager *s_waylandManager;

// 重构后
std::unique_ptr<ShellSurface> m_shellSurface;
static std::unique_ptr<WaylandManager> s_waylandManager;
```

### 现代C++特性应用

```cpp
// 使用 auto 和 optional
auto createWindow(QWidget* widget) -> std::optional<std::unique_ptr<Window>>;

// 结构化绑定
if (auto [success, window] = tryCreateWindow(widget); success) {
    // 处理成功情况
}
```

### Qt最佳实践

```cpp
// 新式信号槽连接
connect(manager, &WaylandManager::activeChanged,
        this, &Window::onProtocolActivated,
        Qt::QueuedConnection);
```

## 风险评估

### 潜在风险
1. **兼容性破坏** - 接口变更可能影响现有代码
2. **性能回归** - 智能指针可能带来轻微性能开销
3. **编译时间** - 模板代码可能增加编译时间

### 缓解策略
1. 保持向后兼容的公共接口
2. 性能基准测试验证
3. 增量重构，分阶段验证

## 成功标准

1. **编译成功** - 零警告零错误
2. **功能完整** - 所有现有功能正常工作
3. **性能维持** - 性能不退化，最好有提升
4. **内存安全** - 无内存泄漏，无野指针
5. **代码质量** - 可读性、可维护性显著提升

## 预期收益

1. **内存安全** - 智能指针消除内存泄漏风险
2. **异常安全** - RAII确保资源正确释放
3. **可维护性** - 更清晰的代码结构和职责分离
4. **性能** - 减少不必要的拷贝和分配
5. **类型安全** - 编译时错误检测
6. **现代化** - 符合现代C++和Qt最佳实践
